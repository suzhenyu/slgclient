# SLG 项目地图核心逻辑分析文档

本文档基于对项目源码的分析，深度梳理了地图系统的核心模块，包括空间管理、数据流、以及关键游戏元素（城市、军队）的渲染与交互逻辑。

## 1. 空间与坐标系统 (`MapUtil.ts`)

`MapUtil.ts` 是整个地图系统的几何与空间基础，它定义了地图的“度量衡”，负责所有与坐标、尺寸、和空间划分相关的计算。

### 核心职责

1.  **初始化配置 (`initMapConfig`)**:
    *   在游戏启动并加载地图资源（`.tmx`）后，此方法被调用。
    *   它读取 Tiled Map 的原始数据，如地图总尺寸 (`mapSize`)、格子尺寸 (`tileSize`)。
    *   **关键逻辑**：根据当前设备的屏幕可见高度，动态计算出最合适的 **区域（Area）** 尺寸 (`areaCellSize`)。这个尺寸决定了按需加载的粒度，是性能优化的关键。

2.  **坐标转换**:
    *   系统内置了多套坐标系，`MapUtil` 提供了它们之间相互转换的静态方法。
    *   `mapCellToPixelPoint(cellPoint)`: 将逻辑上的 **格子坐标** 转换为渲染时使用的 **地图像素坐标**。这是将数据映射到视图的根本。
    *   `mapPixelToCellPoint(pixelPoint)`: 将屏幕上的 **像素坐标**（如触摸点）转换回 **格子坐标**。这是处理用户交互（如点击选中）的根本。

3.  **空间划分与查询**:
    *   `getAreaIdByCellPoint(x, y)`: 根据任意一个格子的坐标，能立刻计算出它所属的 **区域ID**。
    *   `get9GridVaildAreaIds(centerAreaId)`: 这是 **“按需加载”** 机制的核心算法。输入当前屏幕中心点所在的区域ID，此方法会返回一个包含该中心区域及其周围8个邻居的有效区域ID列表（即一个 3x3 的九宫格）。这个列表就是当前需要显示在屏幕上的所有区域。

## 2. 地图数据中枢 (`MapProxy.ts`)

`MapProxy.ts` 是地图的“大脑”和数据中心，扮演着 MVC 架构中 **Model** 的角色。它不处理任何视觉表现，只负责管理地图的所有数据状态，并驱动后续的视图更新。

### 核心职责

1.  **持有静态数据**:
    *   `_mapResDatas`: 一个巨大的数组，存储了从配置文件 `mapRes_0.json` 中加载的、地图上每一个格子的基础信息（例如：`[类型: 52, 等级: 1]` 代表1级林地）。这是地图的“底图”数据。
    *   `_mapResConfigs`: 存储了资源的详细配置信息，例如不同等级的农田每小时的具体产量。

2.  **视野管理与事件派发**:
    *   `setCurCenterPoint(point, pixelPoint)`: 这是地图拖拽和缩放时最高频、最核心的方法。
    *   **状态变更**: 它接收地图相机中心点最新的格子坐标，并判断中心点是否跨越了区域边界。
    *   **计算差异**: 如果确定跨区，它会立即调用 `MapUtil.get9GridVaildAreaIds` 来获取新的九宫格区域，并与旧的九宫格对比，精确计算出 `addIds` (需要新增加载的区域) 和 `removeIds` (需要从视野中移除的区域)。
    *   **派发事件**: 计算完成后，通过全局事件中心派发 `LogicEvent.mapShowAreaChange` 事件，并将 `addIds` 和 `removeIds` 作为参数广播出去。这是驱动所有视图层进行更新的信号源。

3.  **管理服务器请求队列 (`qryAreaIds`)**:
    *   当 `addIds` (新进入视野的区域) 产生时，这些区域的 ID 会被添加到一个名为 `qryAreaIds` 的请求队列中。
    *   场景的主循环 (`MapScene`) 会定时检查这个队列，并从中取出区域 ID，向服务器发起请求，以获取这些区域的动态数据（例如其他玩家的城市、建筑等）。

## 3. 城市渲染逻辑 (`MapCityLogic.ts`)

`MapCityLogic.ts` 是一个具体的 **View** 层实现，专门负责将“城市”这种游戏元素渲染到地图上。它完美地诠释了“数据驱动视图”的思想。

### 核心职责

1.  **继承与监听**:
    *   它继承自一个通用的基类 `MapBaseLayerLogic`，复用了对象池管理、区域加载/卸载的框架代码。
    *   **监听区域变化**: `EventMgr.on(LogicEvent.mapShowAreaChange, ...)`: 这是它最主要的监听。当收到 `MapProxy` 发来的区域变化事件后，它会遍历 `removeIds`，将这些区域的城市节点回收到对象池；同时准备加载 `addIds` 区域的城市。
    *   **监听数据更新**: `EventMgr.on(LogicEvent.updateCitys, ...)`: 当服务器返回了某个区域的城市数据后，对应的 `MapCityProxy` (城市数据模型) 会派发此事件。`MapCityLogic` 监听到后，才开始真正地创建或更新城市节点。

2.  **渲染与更新**:
    *   `addItem(data)`: 当需要显示一个新城市时，此方法被调用。它会从对象池中获取一个城市节点。
    *   `setItemData(item, data)`:
        1.  从 `MapCityProxy` 获取该城市的详细数据 `MapCityData`。
        2.  调用 `MapUtil.mapCellToPixelPoint` 将城市的格子坐标转换为精确的像素坐标。
        3.  设置城市节点在地图容器中的 `position`。
        4.  将完整的 `MapCityData` 传递给城市节点自身的 `CityLogic` 组件，由该组件负责更新自己的外观（例如，不同等级的城市显示不同的模型或特效）。

## 4. 军队渲染与移动逻辑 (`MapArmyLogic.ts`)

`MapArmyLogic.ts` 是另一个 **View** 层实现，但它比 `MapCityLogic` 更复杂，因为它处理的是全地图自由移动的“军队”单位。

### 核心职责

1.  **独立的数据驱动**:
    *   军队是动态的，其位置不与任何一个“区域”绑定，因此它不监听 `mapShowAreaChange` 事件。
    *   它直接监听 `ArmyProxy` (军队数据模型) 派发的事件，如 `updateArmy`。只要任何一支军队的状态（位置、目标、状态）发生变化，它就会收到通知。

2.  **军队实例管理**:
    *   内部维护一个 `Map<number, ArmyLogic>` 结构 (`_armyLogics`)，用于管理当前地图上所有可见的军队实例，`key` 是军队的唯一ID。
    *   当收到 `updateArmy` 通知时，它会检查这支军队是新增的、已存在的还是需要移除的，并从对象池中取用或回收节点。

3.  **实时位置更新 (`update`)**:
    *   在 Cocos Creator 的每一帧 `update` 中，`MapArmyLogic` 会遍历所有军队实例，并调用每个实例的 `update` 方法。
    *   在军队实例内部，会根据**起点、终点、当前时间、总行程时间**进行线性插值计算，从而得到当前帧应该在的精确位置，实现平滑的移动动画。同时处理军队模型的朝向、行军箭头等视觉效果。

4.  **视野裁剪 (`checkVisible`)**:
    *   这是一个非常重要的性能优化。通过一个定时器，`MapArmyLogic` 会周期性地调用 `MapUtil.armyIsInView` 函数。
    *   此函数通过检查军队的起点、当前点、终点是否在某个己方或盟友建筑的“视野范围”（一个 5x5 的格子区域）内，来决定是否显示该军队。这极大地减少了对远在天边、玩家根本看不见的军队进行渲染和计算的开销。

## 5. 总结：优秀的设计实践

该地图系统是一个设计精良、高度优化的工程典范，其核心优势和值得借鉴的最佳实践包括：

1.  **彻底的MVC分层**: `Proxy` (Model) 负责数据和状态，`Logic` (View/Controller) 负责渲染和输入。职责单一，高度解耦。
2.  **空间换时间 (区域加载)**: 通过“九宫格”按需加载机制，从根本上解决了超大尺寸地图的性能瓶颈，使得渲染和计算的负荷保持在一个恒定的低水平。
3.  **极致的对象池复用**: 所有地图实体（资源、城市、建筑、军队）的节点都通过对象池进行管理，最大限度地避免了因频繁创建和销毁节点（`instantiate`/`destroy`）带来的性能抖动。
4.  **灵活的事件驱动架构**: 模块间通过一个全局事件中心 (`EventMgr`) 进行通信。数据层只需关心数据的变化并派发事件，视图层只需监听并响应事件。这种模式极大地降低了模块间的耦合度，使得系统易于扩展。
5.  **动静分离的优化策略**: 对静态的地块（如资源点）和动态的单位（如军队）采用了不同的管理和裁剪策略，兼顾了代码的通用性和优化的针对性。
