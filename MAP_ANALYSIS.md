# SLG 项目地图系统深度分析

本文档旨在深入分析当前 SLG 项目的地图系统实现，为你构建自己的地图系统提供详尽的参考。

## 1. 概述

该地图系统是一个为大型 SLG 游戏设计的、高度优化的系统。其核心设计思想是 **“数据驱动”** 和 **“按需加载”**。

*   **数据驱动**: 地图上的一切实体（地形、资源、城市、建筑）都由预定义的数据 (`.tmx` 文件和 `.json` 配置文件) 和服务器动态数据决定。渲染逻辑只负责将这些数据可视化。
*   **按需加载**: 为了在移动设备上流畅运行超大尺寸的地图（例如 2000x2000），系统不会一次性加载整个地图。它将地图划分为多个 **区域 (Area)**，仅加载并渲染玩家视野内的区域，从而将内存和 CPU 开销降至最低。

项目采用了清晰的 **MVC (Model-View-Controller)** 架构模式，有效分离了数据、视图和逻辑控制，使得代码易于维护和扩展。

## 2. 核心组件与数据结构

### 2.1. Tiled Map (`.tmx` 文件)

地图的基础布局和静态层是在 **Tiled Map Editor** 中创建的，并导出为 `.tmx` 文件。这是地图的“骨架”。

*   **作用**:
    *   定义地图的总尺寸 (`mapSize`)。
    *   定义地图格子（Tile）的尺寸 (`tileSize`)。
    *   包含多个图层 (Layer)，用于定义静态信息。例如：
        *   `ground` (地面层): 绘制基础地形外观。
        *   `obstruct` (障碍物层): 标记哪些格子是不可通行的（如山脉、河流）。
        *   `city_position` (城市位置层): 预设主城、关卡等特殊建筑的生成点。

### 2.2. 地图资源配置文件 (`mapRes_0.json`)

这个文件是地图的“血肉”，定义了每个格子上具体的静态资源信息。它由 `MapTool.ts` 脚本生成。

*   **结构**:
    ```json
    {
      "w": 20, // 地图宽度（格子数）
      "h": 20, // 地图高度（格子数）
      "list": [
        [0, 0],       // 格子 0 (x=0, y=0) 的数据 [类型, 等级]
        [52, 1],      // 格子 1 (x=1, y=0) 的数据 [类型, 等级] (52: 木材, 1: 等级1)
        [51, 8],      // 格子 2 (x=2, y=0) 的数据 [类型, 等级] (51: 系统城市, 8: 等级8)
        // ... 更多格子数据
      ]
    }
    ```
*   **解读**: `list` 是一个一维数组，存储了从左到右、从上到下所有格子的信息。每个格子的数据是一个包含 `[类型, 等级]` 的元组。`MapProxy` 在启动时加载此文件，为整个地图提供基础数据。

## 3. 坐标系统与空间管理

`MapUtil.ts` 是理解地图空间逻辑的关键。

### 3.1. 坐标系

系统内定义了三种核心坐标系，并提供了它们之间的转换方法：

1.  **地图格子坐标 (Map Cell Point)**: `(x, y)`，逻辑网格坐标。这是游戏核心逻辑（如寻路、攻击范围计算）使用的坐标。
2.  **地图像素坐标 (Map Pixel Point)**: 相对于地图节点左上角的像素坐标。用于确定节点在地图容器内的位置。
3.  **世界像素坐标 (World Pixel Point)**: Cocos Creator 场景中的全局坐标。用于处理触摸事件和相机定位。

### 3.2. 空间划分：区域 (Area)

这是性能优化的核心机制。

*   **划分**: `MapUtil.initMapConfig` 在初始化时，会根据屏幕的可见尺寸，动态地将整个地图网格（`mapSize`）划分为更小的 **区域网格 (`areaSize`)**。每个区域包含 `N x N` 个格子 (`areaCellSize`)。
*   **按需加载**: 当玩家移动地图时，系统以当前屏幕中心点所在的区域为中心，计算出一个 **3x3 的九宫格**。这 9 个区域被视为“可见区域”。
*   **加载/卸载**:
    *   当玩家从一个区域移动到相邻区域时，`MapProxy.setCurCenterPoint` 会计算出新进入视野的 3 个区域 (`addIds`) 和离开视野的 3 个区域 (`removeIds`)。
    *   然后，它会派发 `mapShowAreaChange` 事件，通知所有视图组件 (`Logic` 类) 去加载 `addIds` 区域的实体，并卸载/回收 `removeIds` 区域的实体。

这个机制确保了无论地图有多大，同一时间渲染和管理的节点数量都保持在一个可控的范围内。

## 4. MVC 架构详解

### 4.1. Model (数据模型)

*   **`MapProxy.ts`**: 地图数据的“中央银行”。
    *   持有从 `mapRes_0.json` 加载的静态资源数据 (`_mapResDatas`)。
    *   管理所有区域的数据对象 (`MapAreaData`)。
    *   维护当前地图的中心点 (`_curCenterPoint`) 和中心区域 ID (`_curCenterAreaId`)。
    *   管理需要向服务器请求数据的区域队列 (`qryAreaIds`)。
*   **`MapCityProxy.ts`, `MapBuildProxy.ts`**: 存储和管理城市、建筑等动态数据。这些数据通常在与服务器通信后被填充。

### 4.2. View (视图)

视图层由一系列继承自 `Component` 的 `Logic` 类构成，每个类负责渲染地图上的一类特定实体。

*   **`MapBaseLayerLogic.ts`**: 这是一个 **基类**，定义了所有视图逻辑组件的通用行为，如添加/移除区域、添加/更新/移除实体、以及对象池管理。
*   **`MapResLogic.ts`**: 负责渲染资源点（木材、石料等）。
*   **`MapCityLogic.ts`**: 负责渲染玩家和 NPC 的城市。
*   **`MapBuildLogic.ts`**: 负责渲染玩家建造的建筑（要塞、分城等）。
*   **`MapArmyLogic.ts`**: 负责渲染地图上移动的军队。
*   **对象池 (`NodePool`)**: 所有 `Logic` 类都广泛使用对象池来复用节点。当一个实体（如资源点）因移出屏幕而被移除时，它的节点会被回收到对象池中，而不是被销毁。当需要显示同类新实体时，会优先从对象池中获取，极大地降低了 `instantiate` (实例化) 和 `destroy` (销毁) 操作带来的性能开销。

### 4.3. Controller (控制器)

*   **`MapLogic.ts`**: 用户输入的直接处理者。
    *   监听 `TOUCH_MOVE` 事件来实现地图的拖拽。
    *   监听 `MOUSE_WHEEL` 事件来实现地图的缩放。
    *   监听 `TOUCH_END` 事件来处理点击，并将点击的格子坐标通过 `LogicEvent.touchMap` 事件派发出去。
*   **`MapCommand.ts`**: 命令分发中心（单例）。
    *   提供了对所有 `Proxy` 的访问接口，解耦了其他模块对具体 `Proxy` 的直接依赖。
    *   封装了与服务器通信的请求，如 `qryNationMapScanBlock` (请求区域数据)。
*   **`MapScene.ts`**: 场景的总控制器。
    *   负责在场景加载时初始化所有 `Logic` 和 `Proxy` 组件。
    *   管理一个核心计时器 (`onTimer`)，该计时器定期触发向服务器查询可见区域数据的操作。

## 5. 核心工作流程：一次完整的地图拖动

1.  **用户操作**: 用户手指在屏幕上拖动。
2.  **输入捕获**: `MapLogic.onTouchMove` 被触发。
3.  **相机移动**: `MapLogic` 根据拖动距离 `delta`，实时更新 `Map Camera` 的位置。
4.  **中心点更新**: 在移动的同时，`MapLogic` 调用 `MapProxy.setCurCenterPoint`，传入当前相机中心点对应的 **格子坐标**。
5.  **区域变更检测**: `MapProxy` 检查新的中心点是否跨越了区域边界。
    *   **如果跨界**:
        a.  计算出新的九宫格可见区域，并与旧的九宫格对比，得出 `addIds` (需要新增的区域) 和 `removeIds` (需要移除的区域)。
        b.  将 `addIds` 中需要从服务器获取动态数据的区域 ID 加入 `qryAreaIds` 队列。
        c.  派发 `LogicEvent.mapShowAreaChange` 事件，并附带 `addIds` 和 `removeIds`。
6.  **视图更新**:
    *   所有 `Logic` 组件（`MapResLogic`, `MapCityLogic` 等）监听到事件。
    *   它们遍历 `removeIds`，找到属于这些区域的节点，并将其回收到各自的对象池中。
    *   然后遍历 `addIds`，从 `MapProxy` 中获取这些新区域的静态数据，从对象池中取出或创建新节点，并根据数据设置节点的外观和位置，将其显示在地图上。
7.  **服务器数据请求**:
    *   `MapScene` 的 `onTimer` 定时器触发，发现 `MapProxy.qryAreaIds` 队列不为空。
    *   它从队列中取出一个区域 ID，调用 `MapCommand.qryNationMapScanBlock` 向服务器请求该区域的动态数据（如其他玩家的建筑）。
    *   服务器返回数据后，`MapCommand` 将数据填充到对应的 `Proxy`（如 `MapBuildProxy`）中。
    *   `Proxy` 在数据更新后，会派发相应的事件（例如 `LogicEvent.updateBuild`）。
    *   对应的 `Logic` 组件（如 `MapBuildLogic`）监听到事件，更新地图上已有建筑的外观或添加新的建筑。

## 6. 给你的开发建议

这个地图系统是一个非常优秀的工程实践，以下几点尤其值得你在自己的项目中借鉴：

1.  **坚持 MVC 分层**: 严格遵守数据、视图、控制分离的原则。这会让你的项目在功能迭代时，逻辑更清晰，代码更健壮。
2.  **拥抱数据驱动**: 将游戏逻辑建立在对数据的处理上，而不是在视图组件上堆砌逻辑。视图永远只是数据的可视化表现。
3.  **必须实现空间划分**: 对于大地图游戏，**“按需加载/区域加载”** 不是一个可选项，而是一个必需品。你可以完全参考此项目的 `Area` 划分和九宫格加载机制。
4.  **善用对象池**: 在地图这种需要频繁创建和销毁大量相似单位的场景，`NodePool` 是性能优化的关键。确保所有地图实体都通过对象池进行管理。
5.  **建立单例命令中心**: 使用类似 `MapCommand` 的单例来统一管理数据代理和服务器通信，可以极大地简化模块间的通信，降低耦合度。
6.  **抽象视图逻辑基类**: 像 `MapBaseLayerLogic` 一样，为所有处理同类实体的视图逻辑创建一个基类，可以减少大量重复代码。

希望这份详细的分析能对你有所帮助！
